/* generate-octicons
 *
 * Utility script for generating a strongly typed representation of all
 * octicons distributed by the octicons NPM package. Enumerates the icons
 * and generates the TypeScript class containing just what Desktop needs.
 */

import * as fs from 'fs'
import * as Path from 'path'
import * as cp from 'child_process'
import { check } from 'reserved-words'
import toCamelCase from 'to-camel-case'

type OcticonsLib = Record<
  string,
  {
    readonly symbol: string
    readonly heights: Record<
      string,
      {
        readonly ast: {
          readonly children: ReadonlyArray<{
            readonly attributes: {
              readonly d: string
            }
          }>
        }
        readonly options: {
          readonly height: string
          readonly width: string
        }
      }
    >
  }
>

interface IOcticonHeightData {
  readonly p: string[]
  readonly w: number
  readonly h: number
}

interface IOcticonData {
  readonly s: string
  readonly h: Record<string, IOcticonHeightData>
}

function getJsFriendlyName(name: string) {
  const sanitizedName = toCamelCase(name)
  return check(sanitizedName, 'es6', true) ? sanitizedName + '_' : sanitizedName
}

async function generateIconData(): Promise<{
  names: string[]
  sizes: Set<number>
  results: ReadonlyArray<IOcticonData>
}> {
  const octicons: OcticonsLib = require('@primer/octicons')

  const names = Object.keys(octicons).sort()
  const sizes = new Set<number>()

  const results: IOcticonData[] = names.map(name => {
    const octicon = octicons[name]

    if (Object.keys(octicon.heights).length === 0) {
      throw new Error(`Unexpected empty sizes array for ${octicon.symbol}`)
    }

    const heightData: Record<string, IOcticonHeightData> = {}

    Object.entries(octicon.heights).forEach(([height, data]) => {
      sizes.add(parseInt(height, 10))

      heightData[height] = {
        p: data.ast.children.map(c => c.attributes.d),
        h: parseInt(data.options.height, 10),
        w: parseInt(data.options.width, 10),
      }
    })

    return {
      s: octicon.symbol,
      h: heightData,
    }
  })

  return {
    names,
    results,
    sizes,
  }
}

generateIconData().then(({ names, sizes, results }) => {
  console.log(`Writing ${results.length} octicons...`)

  const out = fs.createWriteStream(
    Path.resolve(__dirname, '../app/src/ui/octicons/octicons.generated.ts'),
    {
      encoding: 'utf-8',
    }
  )

  out.write(`/*
 * This file is automatically generated by the generate-octicons tool.
 * Manually changing this file will only lead to sadness.
 */

export type OcticonSymbolName = ${names.map(n => `"${n}"`).join(' | ')}

export type OcticonSymbolSize = ${Array.from(sizes).sort().join(' | ')}

export type OcticonSymbolHeights = { readonly [K in OcticonSymbolSize]?: OcticonSymbolHeight<K> }

export type OcticonSymbolHeight<N extends OcticonSymbolSize> = {
  /** SVG path element data */
  readonly p: string[],

  /** The width of the symbol */
  readonly w: number,

  /** The height of the symbol */
  readonly h: N
}

export type OcticonSymbolType = {
  /** The symbol name */
  readonly s: OcticonSymbolName,

  /** The symbol heights, keyed by height */
  readonly h: OcticonSymbolHeights
}\n\n`)

  results.forEach(({ s, h }) => {
    const name = getJsFriendlyName(s)

    out.write(
      `export const ${name}: OcticonSymbolType = ${JSON.stringify({
        s,
        h,
      })}\n`
    )
  })

  out.end()

  console.log('Ensuring generated file is formatted correctly...')
  const root = Path.dirname(__dirname)
  const yarnExecutable = process.platform === 'win32' ? 'yarn.cmd' : 'yarn'
  return cp.spawn(yarnExecutable, ['lint:fix'], { cwd: root, stdio: 'inherit' })
})
